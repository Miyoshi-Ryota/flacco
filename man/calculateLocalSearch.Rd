% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/ela_feature_local_search.R
\name{calculateLocalSearch}
\alias{calculateLocalSearch}
\title{Calculate Local Search Features}
\usage{
calculateLocalSearch(feat.object, control, ...)
}
\arguments{
\item{feat.object}{[\code{\link{FeatureObject}}]\cr
A feature object as created by \link{createFeatureObject}.\cr
Note, that the feature object has to contain the function itself in
order to compute the local search features.}

\item{control}{[\code{\link{list}}]\cr
A list object that stores additional configuration parameters:\cr
The parameter \code{local.local_searches} defines the number of local
searches. The default is set to \code{50 * d} with \code{d} being the
dimension (i.e., the number of features).\cr
The argument \code{local.optim_method} defines the local search algorithm
(the default is \code{"BFGS"}). The corresponding settings of the local
search algorithm can be defined using \code{local.optim_method_control}.
This has to be a list object.\cr
In order to allow the reproducability of the results, one can also define a
seed (\code{local.sample_seed}), which will be set before the selection of
the initial start points for the local search.\cr
Once the local searches converge, basins have to be assigned. This is done
using hierarchical clustering from \code{\link{hclust}} (per default
\code{local.clust_method} is set to \code{"single"}, i.e.,
\emph{single linkage clustering}).\cr
The distances between merging two clusters are used to define whether
clusters belong together. Per default, \code{local.clust_cut_function}
calculates the \code{10\%}-quantile of all the distances in order to define
the clusters.}

\item{...}{[any]\cr
Further arguments handled by \code{optim}.}
}
\value{
[\code{\link{list}(14)} of \code{\link{numeric}(1)}].\cr
List of features.\cr
For further information, see details.
}
\description{
Computes features based on a local search approach.
}
\details{
Given an initial design, a pre-defined number of local searches
(\code{local.local_searches}) are executed, starting at randomly chosen
points from the initial design.\cr
Those \sQuote{optima} are then clustered (using a hierarchical clustering
approach), considering close local optima belonging to the same basin.
Then, features that are based on the basin sizes as well as on the
(aggregated) objective values of the basins will be returned.\cr

The first two features (\code{ls.n_loc_opt}) return the absolute and
relative number of local optima.\cr
The next two features (\code{ls.best2mean_contr}) compare the ratio of the
best local optimum to the mean of all found local optima.\cr
The following three features (\code{ls.basin_sizes.avg}) aggregate the
basin sizes of the the best, non-best (all except for the best) and worst
basins (w.r.t. the objective value).\cr
The next six features (\code{ls.f_evals}) aggregate the number of
function evaluations, which were needed for the local searches (aggregated
using minimum, 1st quartile, mean, median, 3rd quartile and maximum).\cr
At last, the number of executed function evaluations (\code{ls.fun_evals})
is being computed.

\bold{Note}:\cr
These calculations cause additional function evaluations, caused by the
local search optimization algorithms.
}
\examples{
# (1) create a feature object:
X = t(replicate(n = 2000, expr = runif(n = 5, min = -10, max = 10)))
feat.object = createFeatureObject(X = X, fun = function(x) sum(x^2))

# (2a) compute the convexity features (simple)
calculateLocalSearch(feat.object)
# (2b) compute the convexity features (with some control settings)
cluster_function = function(cl) as.numeric(quantile(cl$height, 0.25))
calculateLocalSearch(feat.object, control = list(
  local.optim_method = "L-BFGS-B",
  local.clust_cut_function = cluster_function,
  lower = -10, upper = 10
))
}
\references{
See Mersmann et al. (2011), \dQuote{Exploratory Landscape Analysis}
(\url{http://dx.doi.org/10.1145/2001576.2001690}).
}

