% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/ela_feature_curvature.R
\name{calculateCurvature}
\alias{calculateCurvature}
\title{Calculate Curvature Features}
\usage{
calculateCurvature(feat.object, control)
}
\arguments{
\item{feat.object}{[\code{\link{FeatureObject}}]\cr
A feature object as created by \link{createFeatureObject}.\cr
Note, that the feature object has to contain the function itself in
order to compute the convexity features.}

\item{control}{[\code{\link{list}}]\cr
A list object that stores additional configuration parameters:\cr
The element \code{curv.sample_size} defines the number of samples that are
used for calculating the features. The default is \code{1000}.}
}
\value{
[\code{\link{list}(21)} of \code{\link{numeric}(1)}].\cr
List of features.\cr
For further information, see details.
}
\description{
Computes features, which quantify the curvature of a function.
}
\details{
Given a feature object, \code{curv.sample_size} (per default
\code{100 * d} with \code{d} being the number of features) samples are
randomly chosen. Then, the gradient and hessian of the function are
estimated based on those points and the following features are computed:\cr

The first seven features (\code{curv.grad_norm}) aggregate the length of
the gradients, the next seven features (\code{curv.grad_scale}) summarize
the ratio of biggest and smallest (absolute) gradient direction and the
remaining seven features (\code{curv.hessian_cond}) summarize the ratio of
biggest and smallest eigenvalue of the hessian matrices. The aggregation
is always done in the same order:\cr
(1) minimum\cr
(2) lower quartile (also known as 1st quartile or \code{25\%}-quantile)\cr
(3) arithmetic mean\cr
(4) median\cr
(5) upper quartile (also known as 3rd quartile or \code{75\%}-quantile)\cr
(6) maximum\cr
(7) standard deviation\cr

\bold{Note:}\cr
These calculations need additional function evaluations. The number of them
heavily depends on the number of iterations needed for estimating the
gradient and hessian of the function.
}
\examples{
# (1) create a feature object:
X = t(replicate(n = 2000, expr = runif(n = 5, min = -10, max = 10)))
feat.object = createFeatureObject(X = X, fun = function(x) sum(x^2))

# (2) compute the curvature features:
calculateCurvature(feat.object)
}
\references{
See Mersmann et al. (2011), \dQuote{Exploratory Landscape Analysis}
(\url{http://dx.doi.org/10.1145/2001576.2001690}).
}

