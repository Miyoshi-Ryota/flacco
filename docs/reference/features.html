<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Calculate Landscape Features — calculateFeatureSet • flacco</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">


<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>

<!-- mathjax -->
<script src='https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">flacco</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/kerschke/flacco">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

      <div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Calculate Landscape Features</h1>
    </div>

    
    <p>Performs an Exploratory Landscape Analysis of a continuous function and
  computes various features, which quantify the function's landscape.
  Currently, the following feature sets are provided:</p><ul>
<li><p>CM: cell mapping features (<code>"cm_angle"</code>, <code>"cm_conv"</code>,
    <code>"cm_grad"</code>)</p></li>
<li><p>ELA: classical ELA features (<code>"ela_conv"</code>,
    <code>"ela_curv"</code>, <code>"ela_distr"</code>, <code>"ela_level"</code>,
    <code>"ela_local"</code>, <code>"ela_meta"</code>)</p></li>
<li><p>GCM: general cell mapping features (<code>"gcm"</code>)</p></li>
<li><p>BT: barrier tree features (<code>"bt"</code>)</p></li>
<li><p>IC: information content features (<code>"ic"</code>)</p></li>
<li><p>Basic: basic features (<code>"basic"</code>)</p></li>
<li><p>Disp: dispersion features (<code>"disp"</code>)</p></li>
<li><p>LiMo: linear model features (<code>"limo"</code>)</p></li>
<li><p>NBC: nearest better clustering features (<code>"nbc"</code>)</p></li>
<li><p>PC: principal component features (<code>"pca"</code>)</p></li>
</ul>
    

    <pre class="usage"><span class='fu'>calculateFeatureSet</span>(<span class='no'>feat.object</span>, <span class='no'>set</span>, <span class='no'>control</span>, <span class='no'>...</span>)

<span class='fu'>calculateFeatures</span>(<span class='no'>feat.object</span>, <span class='no'>control</span>, <span class='no'>...</span>)</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a> Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>feat.object</th>
      <td><p>[<code><a href='FeatureObject.html'>FeatureObject</a></code>]
A feature object as created by <code><a href='FeatureObject.html'>createFeatureObject</a></code>.</p></td>
    </tr>
    <tr>
      <th>set</th>
      <td><p>[<code>character(1)</code>]
Name of the feature set, which should be computed. All possible feature
sets can be listed using <code><a href='listAvailableFeatureSets.html'>listAvailableFeatureSets</a></code>.</p></td>
    </tr>
    <tr>
      <th>control</th>
      <td><p>[<code>list</code>]
A <code>list</code>, which stores additional control arguments.
For further information, see details.</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>[any]
Further arguments, e.g. handled by <code>optim</code> (within the
computation of the ELA local search features) or <code>density</code>
(within the computation of the ELA y-distribution features).</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p><code>list</code> of (<code>numeric</code>) features:</p><ul>
<li><p><code>cm_angle</code> -- angle features (10):
    These features are based on the location of the worst and best element
    within each cell. To be precise, their distance to the cell center and
    the angle between these three elements (at the center) are the
    foundation:</p><ul>
<li><p><code>dist_ctr2{best, worst}.{mean, sd}</code>: arithmetic mean and
      standard deviation of distances from the cell center to the best /
      worst observation within the cell (over all cells)</p></li>
<li><p><code>angle.{mean, sd}</code>: arithmetic mean and standard deviation
      of angles (in degree) between worst, center and best element of a cell
      (over all cells)</p></li>
<li><p><code>y_ratio_best2worst.{mean, sd}</code>: arithmetic mean and
      standard deviation of the ratios between the distance of the worst and
      best element within a cell and the worst and best element in the
      entire initial design (over all cells);
      note that the distances are only measured in the objective space</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>cm_conv</code> -- cell mapping convexity features (6):
    Each cell will be represented by an observation (of the initial design),
    which is located closest to the cell center. Then, the objectives of three
    neighbouring cells are compared:</p><ul>
<li><p><code>{convex, concave}.hard</code>: if the objective of the inner
      cell is above / below the two outer cells, there is strong evidence
      for convexity / concavity</p></li>
<li><p><code>{convex, concave}.soft</code>: if the objective of the inner
      cell is above / below the arithmetic mean of the two outer cells,
      there is weak evidence for convexity / concavity</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>cm_grad</code> -- gradient homogeneity features (4):
    Within a cell of the initial grid, the gradients between each
    observation and its nearest neighbour observation are computed. Those
    gradients are then directed towards the smaller of the two objective
    values and afterwards normalized. Then, the length of the sum of all the
    directed and normalized gradients within a cell is computed. Based on
    those measurements (one per cell) the following features are computed:</p><ul>
<li><p><code>{mean, sd}</code>: arithmetic mean and standard deviation of
      the aforementioned lengths</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>ela_conv</code> -- ELA convexity features (6):
    Two observations are chosen randomly from the initial design. Then, a
    linear (convex) combination of those observations is calculated -- based
    on a random weight from [0, 1]. The corresponding objective value will be
    compared to the linear combination of the objectives from the two
    original observations. This process is replicated <code>convex.nsample</code>
    (per default <code>1000</code>) times and will then be aggregated:</p><ul>
<li><p><code>{convex_p, linear_p}</code>: percentage of convexity / linearity</p></li>
<li><p><code>linear_dev.{orig, abs}</code>: average (original / absolute)
      deviation between the linear combination of the objectives and the
      objective of the linear combination of the observations</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>ela_curv</code> -- ELA curvature features (26):
    Given a feature object, <code>curv.sample_size</code> samples (per default
    <code>100 * d</code> with <code>d</code> being the number of features) are randomly
    chosen. Then, the gradient and hessian of the function are estimated
    based on those points and the following features are computed:</p><ul>
<li><p><code>grad_norm.{min, lq, mean, median, uq, max, sd, nas}</code>:
      aggregations (minimum, lower quartile, arithmetic mean, median, upper
      quartile, maximum, standard deviation and percentage of NAs) of the
      gradients' lengths</p></li>
<li><p><code>grad_scale.{min, lq, mean, median, uq, max, sd, nas}</code>:
      aggregations of the ratios between biggest and smallest (absolute)
      gradient directions</p></li>
<li><p><code>hessian_cond.{min, lq, mean, median, uq, max, sd, nas}</code>:
      aggregations of the ratios of biggest and smallest eigenvalue of the
      hessian matrices</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>ela_distr</code> -- ELA y-distribution features (5):</p><ul>
<li><p><code>skewness</code>: skewness of the objective values</p></li>
<li><p><code>kurtosis</code>: kurtosis of the objective values</p></li>
<li><p><code>number_of_peaks</code>: number of peaks based on an estimation
      of the density of the objective values</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>ela_level</code> -- ELA levelset features (20):</p><ul>
<li><p><code>mmce_{methods}_{quantiles}</code>: mean misclassification error
      of each pair of classification method and quantile</p></li>
<li><p><code>{method1}_{method2}_{quantiles}</code>: ratio of all pairs of
      classification methods for all quantiles</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>ela_local</code> -- ELA local search features (15):
    Based on some randomly chosen points from the initial design, a
    pre-defined number of local searches (<code>ela_local.local_searches</code>)
    are executed. Their optima are then clustered (using hierarchical
    clustering), assuming that local optima that are located close to each
    other, likely belong to the same basin. Given those basins, the
    following features are computed:</p><ul>
<li><p><code>n_loc_opt.{abs, rel}</code>: the absolute / relative amount of
      local optima</p></li>
<li><p><code>best2mean_contr.orig</code>: each cluster is represented by its
      center; this feature is the ratio of the objective values of the best
      and average cluster</p></li>
<li><p><code>best2mean_contr.ratio</code>: each cluster is represented by its
      center; this feature is the ratio of the differences in the objective
      values of average to best and worst to best cluster</p></li>
<li><p><code>basin_sizes.avg_{best, non_best, worst}</code>: average basin
      size of the best / non-best / worst cluster(s)</p></li>
<li><p><code>fun_evals.{min, lq, mean, median, uq, max, sd}</code>:
      aggregations of the performed local searches</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>ela_meta</code> -- ELA meta model features (11):
    Given an initial design, linear and quadratic models of the form
    <code>objective ~ features</code> are created. Both versions are created
    with and without simple interactions (e.g., <code>x1:x2</code>). Based on
    those models, the following features are computed:</p><ul>
<li><p><code>lin_simple.{adj_r2, intercept}</code>: adjusted R^2 (i.e. model
      fit) and intercept of a simple linear model</p></li>
<li><p><code>lin_simple.coef.{min, max, max_by_min}</code>: smallest and
      biggest (non-intercept) absolute coefficients of the simple linear
      model, and their ratio</p></li>
<li><p><code>{lin_w_interact, quad_simple, quad_w_interact}.adj_r2</code>:
      adjusted R^2 (i.e. the model fit) of a linear model with interactions,
      and a quadratic model with and without interactions</p></li>
<li><p><code>quad_simple.cond</code>: condition of a simple quadratic model
      (without interactions), i.e. the ratio of its (absolute) biggest and
      smallest coefficients</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>gcm</code> -- general cell mapping (GCM) features (75):
    Computes general cell mapping features based on the Generalized Cell
    Mapping (GCM) approach, which interpretes the cells as absorbing Markov
    chains. Computations are performed based on three different approaches:
    taking the best (<code>min</code>) or average (<code>mean</code>) objective value of
    a cell or the closest observation (<code>near</code>) to a cell as
    representative. For each of these approaches the following 25 features
    are computed:</p><ul>
<li><p><code>attractors, pcells, tcells, uncertain</code>: relative amount
      of attractor, periodic, transient and uncertain cells</p></li>
<li><p><code>basin_prob.{min, mean, median, max, sd}</code>: aggregations
      of the probabilities of each basin of attraction</p></li>
<li><p><code>basin_certain.{min, mean, median, max, sd}</code>: aggregations
      of the (relative) size of each basin of attraction, in case only
      certain cells are considered (i.e. cells, which only point towards one
      attractor)</p></li>
<li><p><code>basin_uncertain.{min, mean, median, max, sd}</code>:
      aggregations of the (relative) size of each basin of attraction, in
      case uncertain cells are considered (i.e. a cell, which points to
      multiple attractors contributes to each of its basins)</p></li>
<li><p><code>best_attr.{prob, no}</code>: probability of finding the
      attractor with the best objective value and the (relative) amount of
      those attractors (i.e. the ratio of the number of attractors with the
      best objective value and the total amount of cells)</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>bt</code> -- barrier tree features (90):
    Computes barrier tree features, based on a Generalized Cell Mapping
    (GCM) approach. Computations are performed based on three different
    approaches: taking the best (<code>min</code>) or average (<code>mean</code>)
    objective value of a cell or the closest observation (<code>near</code>) to a
    cell as representative. For each of these approaches the following 31
    features are computed:</p><ul>
<li><p><code>levels</code>: absolute number of levels of the barrier tree</p></li>
<li><p><code>leaves</code>: absolute number of leaves (i.e. local optima)
      of the barrier tree</p></li>
<li><p><code>depth</code>: range between highest and lowest node of the tree</p></li>
<li><p><code>depth_levels_ratio</code>: ratio of depth and levels</p></li>
<li><p><code>levels_nodes_ratio</code>: ratio of number of levels and number
      of (non-root) nodes of the tree</p></li>
<li><p><code>diffs.{min, mean, median, max, sd}</code>:
      aggregations of the height differences between a node and its
      predecessor</p></li>
<li><p><code>level_diffs.{min, mean, median, max, sd}</code>:
      aggregations of the average height differences per level</p></li>
<li><p><code>attractor_dists.{min, mean, median, max, sd}</code>:
      aggregations of the (euclidean) distances between the local and global
      best cells (attractors)</p></li>
<li><p><code>basin_ratio.{uncertain, certain, most_likely}</code>:
      ratios of maximum and minimum size of the basins of attractions; here,
      a cell might belong to different attractors (uncertain), exactly one
      attractor (certain) or the attractor with the highest probability</p></li>
<li><p><code>basin_intersection.{min, mean, median, max, sd}</code>:
      aggregations of the intersection between the basin of the global best
      value and the basins of all local best values</p></li>
<li><p><code>basin_range</code>:
      range of a basin (euclidean distance of widest range per dimension)</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>ic</code> -- information content features (7):
    Computes features based on the Information Content of Fitness Sequences
    (ICoFiS) approach (cf. Munoz et al., 2015). In this approach, the
    information content of a continuous landscape, i.e. smoothness,
    ruggedness, or neutrality, are quantified. While common analysis methods
    were able to calculate the information content of discrete landscapes,
    the ICoFiS approach provides an adaptation to continuous landscapes that
    accounts e.g. for variable step sizes in random walk sampling:</p><ul>
<li><p><code>h.max</code>: &#8220;maximum information content&#8221; (entropy) of
     the fitness sequence, cf. equation (5)</p></li>
<li><p><code>eps.s</code>: &#8220;settling sensitivity&#8221;, indicating the
     epsilon for which the sequence nearly consists of zeros only, cf.
     equation (6)</p></li>
<li><p><code>eps.max</code>: similar to <code>eps.s</code>, but in contrast to the
     former <code>eps.max</code> guarantees non-missing values; this simply is the
     epsilon-value for which H(<code>eps.max</code>) == <code>h.max</code></p></li>
<li><p><code>eps.ratio</code>: &#8220;ratio of partial information
     sensitivity&#8221;, cf. equation (8), where the ratio is <code>0.5</code></p></li>
<li><p><code>m0</code>: &#8220;initial partial information&#8221;, cf. equation
     (7)</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
     function evaluations and runtime (in seconds), which were needed for
     the computation of these features</p></li>
</ul></li>
<li><p><code>basic</code> -- basic features (15):
    Very simple features, which can be read from the feature object (without
    any computational efforts):</p><ul>
<li><p><code>{dim, observations}</code>: number of features / dimensions and
      observations within the initial sample</p></li>
<li><p><code>{lower, upper, objective, blocks}_{min, max}</code>: minimum
      and maximum value of all lower and upper bounds, the objective values
      and the number of blocks / cells (per dimension)</p></li>
<li><p><code>cells_{filled, total}</code>: number of filled (i.e. non-empty)
      cells and total number of cells</p></li>
<li><p><code>{minimize_fun}</code>: logical value, indicating
      whether the optimization function should be minimized</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>disp</code> -- dispersion features (18):
    Computes features based on the comparison of the dispersion of pairwise
    distances among the 'best' elements and the entire initial design:</p><ul>
<li><p><code>{ratio, diff}_{mean, median}_{02, 05, 10, 25}</code>: ratio
      and difference of the mean / median distances of the distances of the
      'best' objectives vs. 'all' objectives</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>limo</code> -- linear model features (14):
    Linear models are computed per cell, provided the decision space is
    divided into a grid of cells. Each one of the models has the form
    <code>objective ~ features</code>.</p><ul>
<li><p><code>avg_length.{reg, norm}</code>: length of the average
      coefficient vector (based on regular and normalized vectors)</p></li>
<li><p><code>length_{mean, sd}</code>: arithmetic mean and standard
      deviation of the lengths of all coefficient vectors</p></li>
<li><p><code>cor.{reg, norm}</code>: correlation of all coefficient vectors
      (based on regular and normalized vectors)</p></li>
<li><p><code>ratio_{mean, sd}</code>: arithmetic mean and standard deviation
      of the ratios of (absolute) maximum and minimum (non-intercept)
      coefficients per cell</p></li>
<li><p><code>sd_{ratio, mean}.{reg, norm}</code>: max-by-min-ratio and
      arithmetic mean of the standard deviations of the (non-intercept)
      coefficients (based on regular and normalized vectors)</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>nbc</code> -- nearest better (clustering) features (7):
    Computes features based on the comparison of nearest neighbour and
    nearest better neighbour, i.e., the nearest neighbor with a better
    performance / objective value value.</p><ul>
<li><p><code>nn_nb.{sd, mean}_ratio</code>: ratio of standard deviations and
      arithmetic mean based on the distances among the nearest neighbours
      and the nearest better neighbours</p></li>
<li><p><code>nn_nb.cor</code>: correlation between distances of the nearest
      neighbours and the distances of the nearest better neighbours</p></li>
<li><p><code>dist_ratio.coeff_var</code>: coefficient of variation of the
      distance ratios</p></li>
<li><p><code>nb_fitness.cor</code>: correlation between fitness value and
      count of observations to whom the current observation is the nearest
      better neighbour (the so-called &#8220;indegree&#8221;).</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
<li><p><code>pca</code> -- principal component (analysis) features (10):</p><ul>
<li><p><code>expl_var.{cov, cor}_{x, init}</code>: proportion of the
      explained variance when applying PCA to the covariance / correlation
      matrix of the decision space (<code>x</code>) or the entire initial design
      (<code>init</code>)</p></li>
<li><p><code>expl_var_PC1.{cov, cor}_{x, init}</code>: proportion of
      variance, which is explained by the first principal component -- when
      applying PCA to the covariance / correlation matrix of the decision
      space (<code>x</code>) or the entire initial design</p></li>
<li><p><code>costs_{fun_evals, runtime}</code>: number of (additional)
      function evaluations and runtime (in seconds), which were needed for
      the computation of these features</p></li>
</ul></li>
</ul>

    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>Note that if you want to speed up the runtime of the features, you might
  consider running your feature computation parallelized. For more
  information, please refer to the <code>parallelMap</code> package or to
  <a href = 'http://mlr-org.github.io/mlr-tutorial/release/html/parallelization/index.html'>http://mlr-org.github.io/mlr-tutorial/release/html/parallelization/index.html</a>.</p>
<p>Furthermore, please consider adapting the feature computation to your
  needs. Possible <code>control</code> arguments are:</p><ul>
<li><p>general:</p><ul>
<li><p><code>show_progress</code>: Show progress bar when computing the
      features? The default is <code>TRUE</code>.</p></li>
<li><p><code>subset</code>: Specify a subset of features that should be
      computed. Per default, all features will be computed.</p></li>
<li><p><code>allow_cellmapping</code>: Should cell mapping features be
      computed? The default is <code>TRUE</code>.</p></li>
<li><p><code>allow_costs</code>: Should expensive features, i.e. features,
      which require additional function evaluations, be computed? The
      default is <code>TRUE</code> if the feature object provides a function,
      otherwise <code>FALSE</code>.</p></li>
<li><p><code>blacklist</code>: Which features should NOT be computed? The
      default is <code>NULL</code>, i.e. none of the features will be excluded.</p></li>
</ul></li>
<li><p>cell mapping angle features:</p><ul>
<li><p><code>cm_angle.show_warnings</code>: Should possible warnings about
      <code>NAs</code> in the feature computation be shown? The default is
      <code>FALSE</code>.</p></li>
</ul></li>
<li><p>cell mapping convexity features:</p><ul>
<li><p><code>cm_conv.diag</code>: Should cells, which are located on the
      diagonal compared to the current cell, be considered as neighbouring
      cells? The default is <code>FALSE</code>, i.e. only cells along the axes
      are considered as neighbours.</p></li>
<li><p><code>cm_conv.dist_method</code>: Which distance method should be
      used for computing the distance between two observations? All methods
      of <code>dist</code> are possible options with <code>"euclidean"</code>
      being the default.</p></li>
<li><p><code>cm_conv.minkowski_p</code>: Value of <code>p</code> in case
      <code>dist_meth</code> is <code>"minkowski"</code>. The default is <code>2</code>, i.e.
      the euclidean distance.</p></li>
<li><p><code>cm_conv.fast_k</code>: Percentage of elements that should be
      considered within the nearest neighbour computation. The default is
      <code>0.05</code>.</p></li>
</ul></li>
<li><p>cell mapping gradient homogeneity features:</p><ul>
<li><p><code>cm_grad.dist_tie_breaker</code>: How will ties be broken when
      different observations have the same distance to an observation?
      Possible values are <code>"sample"</code>, <code>"first"</code> and <code>"last"</code>.
      The default is <code>"sample"</code>.</p></li>
<li><p><code>cm_grad.dist_method</code>: Which distance method should be
      used for computing the distance between two observations? All methods
      of <code>dist</code> are possible options with <code>"euclidean"</code>
      being the default.</p></li>
<li><p><code>cm_grad.minkowski_p</code>: Value of <code>p</code> in case
      <code>dist_meth</code> is <code>"minkowski"</code>. The default is <code>2</code>, i.e.
      the euclidean distance.</p></li>
<li><p><code>cm_grad.show_warnings</code>: Should possible warnings about
      (almost) empty cells be shown? The default is <code>FALSE</code>.</p></li>
</ul></li>
<li><p>ELA convexity features:</p><ul>
<li><p><code>ela_conv.nsample</code>: Number of samples that are drawn for
      calculating the convexity features. The default is <code>1000</code>.</p></li>
<li><p><code>ela_conv.threshold</code>: Threshold of the linearity, i.e. the
      tolerance to / deviation from perfect linearity, in order to still be
      considered linear. The default is <code>1e-10</code>.</p></li>
</ul></li>
<li><p>ELA curvature features:</p><ul>
<li><p><code>ela_curv.sample_size</code>: Number of samples used for
      calculating the curvature features. The default is <code>100*d</code>.</p></li>
<li><p><code>ela_curv.{delta, eps, zero_tol, r, v}</code>: Parameters used
      by <code><a href='http://www.rdocumentation.org/packages/numDeriv/topics/grad'>grad</a></code> and <code><a href='http://www.rdocumentation.org/packages/numDeriv/topics/hessian'>hessian</a></code> within the
      approximation of the gradient and hessian. The default values are
      identical to the ones from the corresponding functions. Note that we
      slightly modified <code><a href='http://www.rdocumentation.org/packages/numDeriv/topics/hessian'>hessian</a></code> in order to assure
      that we do not exceed the boundaries during the estimation of the
      Hessian.</p></li>
</ul></li>
<li><p>ELA distribution features:</p><ul>
<li><p><code>ela_distr.smoothing_bandwidth</code>: The smoothing bandwidth,
      which should be used within the <code>density</code> estimation.
      The default is <code>"SJ"</code>.</p></li>
<li><p><code>ela_distr.modemass_threshold</code>: Threshold that is used in
      order to classify whether a minimum can be considered as a peak.
      The default is <code>0.01</code>.</p></li>
<li><p><code>ela_distr.skewness_type</code>: Algorithm type for computing
      the <code><a href='http://www.rdocumentation.org/packages/e1071/topics/skewness'>skewness</a></code>. The default is <code>3</code>.</p></li>
<li><p><code>ela_distr.kurtosis_type</code>: Algorithm type for computing
      the <code><a href='http://www.rdocumentation.org/packages/e1071/topics/kurtosis'>kurtosis</a></code>. The default is <code>3</code>.</p></li>
</ul></li>
<li><p>ELA levelset features:</p><ul>
<li><p><code>ela_level.quantiles</code>: Cutpoints (quantiles of the
      objective values) for splitting the objective space. The default is
      <code>c(0.10, 0.25, 0.50)</code>.</p></li>
<li><p><code>ela_level.classif_methods</code>: Methods for classifying
      the artificially splitted objective space. The default is
      <code>c("lda", "qda", "mda")</code>.</p></li>
<li><p><code>ela_level.resample_method</code>: Resample technique for
      training the model, cf. <code><a href='http://www.rdocumentation.org/packages/mlr/topics/makeResampleDesc'>ResampleDesc</a></code>. The default
      is <code>"CV"</code>.</p></li>
<li><p><code>ela_level.resample_iterations</code>: Number of iterations
      of the resampling method. The default is <code>10</code>.</p></li>
<li><p><code>ela_level.resample_info</code>: Should information regarding
      the resampling be printed? The default is <code>FALSE</code>.</p></li>
<li><p><code>ela_level.parallelize</code>: Should the levelset features be
      computed in parallel? The default is <code>FALSE</code>.</p></li>
<li><p><code>ela_level.parallel.mode</code>: Which mode should be used for
      the parallelized computation? Possible options are <code>"local"</code>,
      <code>"multicore"</code>, <code>"socket"</code> (default), <code>"mpi"</code> and
      <code>"BatchJobs"</code>. Note that in case you are using a windows computer
      you can only use the <code>"socket"</code> mode.</p></li>
<li><p><code>ela_level.parallel.cpus</code>: On how many cpus do you want to
      compute the features in parallel? Per default, all available cpus are
      used.</p></li>
<li><p><code>ela_level.parallel.level</code>: On which level should the
      parallel computation be performed? The default is
      <code>"mlr.resample"</code>, i.e. the internal resampling (performed using
      <code>mlr</code>) will be done in parallel.</p></li>
<li><p><code>ela_level.parallel.logging</code>: Should slave output be
      logged? The default is <code>FALSE</code>.</p></li>
<li><p><code>ela_level.parallel.show_info</code>: Should verbose output of
      function calls be printed on the console? The default is <code>FALSE</code>.</p></li>
</ul></li>
<li><p>ELA local search features:</p><ul>
<li><p><code>ela_local.local_searches</code>: Number of local searches. The
      default is <code>50 * d</code> with <code>d</code> being the number of features
      (i.e. the dimension).</p></li>
<li><p><code>ela_local.optim_method</code>: Local search algorithm. The
      default is <code>"L-BFGS-B"</code>.</p></li>
<li><p><code>ela_local.optim.{lower, upper}</code>: Lower and upper bounds
      to be considered by the local search algorithm. Per default, the
      boundaries are the same as defined within the feature object
      (in case of <code>"L-BFGS-B"</code>) or infinity (for all others).</p></li>
<li><p><code>ela_local.optim_method_control</code>: Control settings of the
      local search algorithm. The default is an empty list.</p></li>
<li><p><code>ela_local.sample_seed</code>: Seed, which will be set before
      the selection of the initial start points of the local search. The
      default is <code>sample(1:1e6, 1)</code>.</p></li>
<li><p><code>ela_local.clust_method</code>: Once the local searches
      converge, basins have to be assigned. This is done using hierarchical
      clustering methods from <code>hclust</code>. The default is
      <code>"single"</code>, i.e. <em>single linkage clustering</em>.</p></li>
<li><p><code>ela_local.clust_cut_function</code>: A function of a
      hierarchical clustering <code>cl</code>, which defines at which height the
      dendrogramm should be splitted into clusters
      (cf. <code>cutree</code>). The default is
      <code>function(cl) as.numeric(quantile(cl$height, 0.1))</code>, i.e. the
      <code>10%</code>-quantile of all the distances between clusters.</p></li>
</ul></li>
<li><p>GCM features:</p><ul>
<li><p><code>gcm.approaches</code>: Which approach(es) should be used when
      computing the representatives of a cell. The default are all three
      approaches, i.e. <code>c("min", "mean", "near")</code>.</p></li>
<li><p><code>gcm.cf_power</code>: Theoretically, we need to compute the
      canonical form to the power of infinity. However, we use this value
      as approximation of infinity. The default is <code>256</code>.</p></li>
</ul></li>
<li><p>barrier tree features:</p><ul>
<li><p><code>gcm.approaches</code>: Which approach(es) should be used when
      computing the representatives of a cell. The default are all three
      approaches, i.e. <code>c("min", "mean", "near")</code>.</p></li>
<li><p><code>gcm.cf_power</code>: Theoretically, we need to compute the
      canonical form to the power of infinity. However, we use this value
      as approximation of infinity. The default is <code>256</code>.</p></li>
<li><p><code>bt.base</code>: Maximum number of basins, which are joined at a
      single breakpoint. The default is <code>4L</code>.</p></li>
<li><p><code>bt.max_depth</code>: Maximum number of levels of the barrier
      tree. The default is <code>16L</code>.</p></li>
</ul></li>
<li><p>information content features:</p><ul>
<li><p><code>ic.epsilon</code>: Epsilon values as described in section V.A
      of Munoz et al. (2015). The default is
      <code>c(0, 10^(seq(-5, 15, length.out = 1000))</code>.</p></li>
<li><p><code>ic.sorting</code>: Sorting strategy, which is used to define
      the tour through the landscape. Possible values are <code>"nn"</code>
      (= default) and <code>"random"</code>.</p></li>
<li><p><code>ic.sample.generate</code>: Should the initial design be created
      using a LHS? The default is <code>FALSE</code>, i.e. the initial design from
      the feature object will be used.</p></li>
<li><p><code>ic.sample.dimensions</code>: Dimensions of the initial design,
      if created using a LHS. The default is <code>feat.object$dimension</code>.</p></li>
<li><p><code>ic.sample.size</code>: Size of the initial design, if created
      using a LHS. The default is <code>100 * feat.object$dimension</code>.</p></li>
<li><p><code>ic.sample.lower</code>: Lower bounds of the initial design, if
      created with a LHS. The default is <code>100 * feat.object$lower</code>.</p></li>
<li><p><code>ic.sample.upper</code>: Upper bounds of the initial design, if
      created with a LHS. The default is <code>100 * feat.object$upper</code>.</p></li>
<li><p><code>ic.aggregate_duplicated</code>: How should observations, which
      have duplicates in the decision space, be aggregated? The default is
      <code>mean</code>.</p></li>
<li><p><code>ic.show_warnings</code>: Should warnings be shown, when
      possible duplicates are removed? The default is <code>FALSE</code>.</p></li>
<li><p><code>ic.seed</code>: Possible seed, which can be used for making
      your experiments reproducable. Per default, a random number will be
      drawn as seed.</p></li>
<li><p><code>ic.nn.start</code>: Which observation should be used as
      starting value, when exploring the landscape with the nearest
      neighbour approach. The default is a randomly chosen integer value.</p></li>
<li><p><code>ic.nn.neighborhood</code>: In order to provide a fast
      computation of the features, we use <code>RANN::nn2</code> for computing
      the nearest neighbors of an observation. Per default, we consider
      the <code>20L</code> closest neighbors for finding the nearest
      not-yet-visited observation. If all of those neighbors have been
      visited already, we compute the distances to the remaining points
      separately.</p></li>
<li><p><code>ic.settling_sensitivity</code>: Threshold, which should be
      used for computing the &#8220;settling sensitivity&#8221;. The default
      is <code>0.05</code> (as used in the corresponding paper).</p></li>
<li><p><code>ic.info_sensitivity</code>: Portion of partial information
      sensitivity. The default is <code>0.5</code> (as used in the paper).</p></li>
</ul></li>
<li><p>dispersion features:</p><ul>
<li><p><code>disp.quantiles</code>: Quantiles, which should be used for
      defining the "best" elements of the entire initial design. The default
      is <code>c(0.02, 0.05, 0.1, 0.25)</code>.</p></li>
<li><p><code>disp.dist_method</code>: Which distance method should be
      used for computing the distance between two observations? All methods
      of <code>dist</code> are possible options with <code>"euclidean"</code>
      being the default.</p></li>
<li><p><code>disp.minkowski_p</code>: Value of <code>p</code> in case
      <code>dist_meth</code> is <code>"minkowski"</code>. The default is <code>2</code>, i.e.
      the euclidean distance.</p></li>
</ul></li>
<li><p>nearest better clustering features:</p><ul>
<li><p><code>nbc.dist_method</code>: Which distance method should be
      used for computing the distance between two observations? All methods
      of <code>dist</code> are possible options with <code>"euclidean"</code>
      being the default.</p></li>
<li><p><code>nbc.minkowski_p</code>: Value of <code>p</code> in case
      <code>dist_meth</code> is <code>"minkowski"</code>. The default is <code>2</code>, i.e.
      the euclidean distance.</p></li>
<li><p><code>nbc.dist_tie_breaker</code>: How will ties be broken when
      different observations have the same distance to an observation?
      Possible values are <code>"sample"</code>, <code>"first"</code> and <code>"last"</code>.
      The default is <code>"sample"</code>.</p></li>
<li><p><code>nbc.cor_na</code>: How should NA's be handled when computing
      correlations? Any method from the argument <code>use</code> of the function
      <code>cor</code> is possible. The default is
      <code>"pairwise.complete.obs"</code>.</p></li>
<li><p><code>nbc.fast_k</code>: In case of euclidean distances, the method
      can find neighbours faster. This parameter controls the percentage of
      observations that should be considered when looking for the nearest
      better neighbour, i.e. the nearest neighbour with a better objective
      value. The default is <code>0.05</code>, i.e. the 5<!-- % nearest neighbours. --></p></li>
</ul></li>
<li><p>principal component features:</p><ul>
<li><p><code>pca.{cov, cor}_{x, init}</code>: Which proportion of the
      variance should be explained by the principal components given a
      principal component analysis based on the covariance / correlation
      matrix of the decision space (<code>x</code>) or the entire initial
      design (<code>init</code>)? The defaults are <code>0.9</code>.</p></li>
</ul></li>
</ul>
    
    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <ul>
<li><p>Kerschke, P., Preuss, M., Hernandez, C., Schuetze, O., Sun, J.-Q.,
    Grimme, C., Rudolph, G., Bischl, B., and Trautmann, H. (2014):
    &#8220;Cell Mapping Techniques for Exploratory Landscape Analysis&#8221;,
    in: EVOLVE -- A Bridge between Probability, Set Oriented Numerics, and
    Evolutionary Computation V, pp. 115-131
    (<a href = 'http://dx.doi.org/10.1007/978-3-319-07494-8_9'>http://dx.doi.org/10.1007/978-3-319-07494-8_9</a>).</p></li>
<li><p>Kerschke, P., Preuss, M., Wessing, S., and Trautmann, H. (2015):
    &#8220;Detecting Funnel Structures by Means of Exploratory Landscape
    Analysis&#8221;, in: Proceedings of the 17th Annual Conference on Genetic and
    Evolutionary Computation (GECCO '15), pp. 265-272
    (<a href = 'http://dx.doi.org/10.1145/2739480.2754642'>http://dx.doi.org/10.1145/2739480.2754642</a>).</p></li>
<li><p>Lunacek, M., and Whitley, D. (2006):
    &#8220;The dispersion metric and the CMA evolution strategy&#8221;, in:
    Proceedings of the 8th Annual Conference on Genetic and Evolutionary
    Computation (GECCO '06), pp. 477-484
    (<a href = 'http://dx.doi.org/10.1145/1143997.1144085'>http://dx.doi.org/10.1145/1143997.1144085</a>).</p></li>
<li><p>Mersmann, O., Bischl, B., Trautmann, H., Preuss, M., Weihs, C.,
    and Rudolph, G. (2011): &#8220;Exploratory Landscape Analysis&#8221;, in:
    Proceedings of the 13th Annual Conference on Genetic and Evolutionary
    Computation (GECCO '11), pp. 829-836
    (<a href = 'http://dx.doi.org/10.1145/2001576.2001690'>http://dx.doi.org/10.1145/2001576.2001690</a>).</p></li>
<li><p>Munoz, M. A., Kirley, M., and Halgamuge, S. K. (2015):
    &#8220;Exploratory Landscape Analysis of Continuous Space Optimization
    Problems Using Information Content&#8221;, in: IEEE Transactions on
    Evolutionary Computation (19:1), pp. 74-87
    (<a href = 'http://dx.doi.org/10.1109/TEVC.2014.2302006'>http://dx.doi.org/10.1109/TEVC.2014.2302006</a>).</p></li>
</ul>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'># (1) create a feature object:</span>
<span class='no'>X</span> <span class='kw'>=</span> <span class='fu'>t</span>(<span class='fu'>replicate</span>(<span class='kw'>n</span> <span class='kw'>=</span> <span class='fl'>2000</span>, <span class='kw'>expr</span> <span class='kw'>=</span> <span class='fu'>runif</span>(<span class='kw'>n</span> <span class='kw'>=</span> <span class='fl'>5</span>, <span class='kw'>min</span> <span class='kw'>=</span> -<span class='fl'>10</span>, <span class='kw'>max</span> <span class='kw'>=</span> <span class='fl'>10</span>)))
<span class='co'>## Not run: feat.object = createFeatureObject(X = X, fun = function(x) sum(x^2))</span>

<span class='co'># (2) compute all non-cellmapping features</span>
<span class='no'>ctrl</span> <span class='kw'>=</span> <span class='fu'>list</span>(<span class='kw'>allow_cellmapping</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)
<span class='co'>## Not run: features = calculateFeatures(feat.object, control = ctrl)</span>

<span class='co'># (3) in order to allow the computation of the cell mapping features, one</span>
<span class='co'># has to provide a feature object that has knowledge about the number of</span>
<span class='co'># cells per dimension:</span>
<span class='no'>f</span> <span class='kw'>=</span> <span class='kw'>function</span>(<span class='no'>x</span>) <span class='fu'>sum</span>(<span class='no'>x</span>^<span class='fl'>2</span>)
<span class='no'>feat.object</span> <span class='kw'>=</span> <span class='fu'><a href='FeatureObject.html'>createFeatureObject</a></span>(<span class='kw'>X</span> <span class='kw'>=</span> <span class='no'>X</span>, <span class='kw'>fun</span> <span class='kw'>=</span> <span class='no'>f</span>, <span class='kw'>blocks</span> <span class='kw'>=</span> <span class='fl'>3</span>)
<span class='co'>## Not run: features = calculateFeatures(feat.object)</span>

<span class='co'># (4) if you want to compute a specific feature set, you can use</span>
<span class='co'># calculateFeatureSet:</span>
<span class='no'>features.angle</span> <span class='kw'>=</span> <span class='fu'>calculateFeatureSet</span>(<span class='no'>feat.object</span>, <span class='st'>"cm_angle"</span>)

<span class='co'># (5) as noted in the details, it might be useful to compute the levelset</span>
<span class='co'># features parallelized:</span>
<span class='fu'>not_run</span>({
  <span class='fu'>library</span>(<span class='no'>parallelMap</span>)
  <span class='fu'>library</span>(<span class='no'>parallel</span>)
  <span class='no'>n.cores</span> <span class='kw'>=</span> <span class='fu'>detectCores</span>()
  <span class='fu'>parallelStart</span>(<span class='kw'>mode</span> <span class='kw'>=</span> <span class='st'>"socket"</span>, <span class='kw'>cpus</span> <span class='kw'>=</span> <span class='no'>n.cores</span>,
    <span class='kw'>logging</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>, <span class='kw'>show.info</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)
  <span class='fu'>system.time</span>((<span class='no'>levelset.par</span> <span class='kw'>=</span> <span class='fu'>calculateFeatureSet</span>(<span class='no'>feat.object</span>, <span class='st'>"ela_level"</span>)))
  <span class='fu'>parallelStop</span>()
  <span class='fu'>system.time</span>((<span class='no'>levelset.seq</span> <span class='kw'>=</span> <span class='fu'>calculateFeatureSet</span>(<span class='no'>feat.object</span>, <span class='st'>"ela_level"</span>)))
})</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#value">Value</a></li>

      <li><a href="#details">Details</a></li>

      <li><a href="#references">References</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Pascal Kerschke.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  </body>
</html>
