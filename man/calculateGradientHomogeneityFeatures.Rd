% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/cm_feature_gradient_homogeneity.R
\name{calculateGradientHomogeneityFeatures}
\alias{calculateGradientHomogeneityFeatures}
\title{Calculate Gradient Homogeneity Features}
\usage{
calculateGradientHomogeneityFeatures(feat.object, control, show.warnings)
}
\arguments{
\item{feat.object}{[\code{\link{FeatureObject}}]\cr
A feature object as created by \link{createFeatureObject}.}

\item{control}{[\code{\link{list}}]\cr
A list object that stores additional configuration parameters:\cr
The element \code{gradhomo.dist_tie_breaker} defines how ties will be broken
(using \code{selectMin}) when different observations have the same distance
to an observation. Possible values are \code{sample}, \code{first} and
\code{last}. The default is \code{sample}.}

\item{show.warnings}{[\code{\link{logical}(1)}]\cr
Should possible warnings about (almost) empty cells be shown? The default is
\code{show.warnings = TRUE}.}
}
\value{
[\code{\link{list}(4)}].\cr
List of features.\cr
For further information, see details.
}
\description{
Computes features based on the gradient homogeneity, i.e. the sum of the
directed and normalized gradients within a cell.
}
\details{
Within a cell of the initial grid, the gradients from each observation to its
nearest observation are computed and directed towards the smaller of the two
objective values. Each of those directed gradients will be normalized.
Then, the length of the sum of all the directed and normalized gradients
within a cell is computed. Based on those measurements (one per cell), this
function computes two features:\cr

1) The arithmetic mean of those length's; it should lie within [-1, +1].\cr
2) Their standard deviation.\cr

The final two features show the amount of (additional) function
evaluations and running time (in seconds) that were needed for the
computation of these features.
}
\examples{
# (1) create a feature object:
X = t(replicate(n = 1000, expr = runif(n = 3)))

feat.object = createFeatureObject(X = X,
  fun = function(x) sum(x^2), blocks = c(5, 10, 4))

# (2) compute the gradient homogeneity features:
calculateGradientHomogeneityFeatures(feat.object = feat.object)
}
\references{
See Kerschke et al. (2014), \dQuote{Cell Mapping Techniques for Exploratory Landscape Analysis},
 in EVOLVE-A Bridge between Probability, Set Oriented Numerics, and Evolutionary Computation V,
 pp. 115-131 (\url{http://dx.doi.org/10.1007/978-3-319-07494-8_9}).
}

